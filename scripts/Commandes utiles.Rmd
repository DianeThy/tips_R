---
title: "Commandes utiles"
author: "Diane Thierry"
date: "Màj le `r Sys.Date()`"
output: 
    html_document:
        theme: paper
        highlight: textmate
        toc: yes
        toc_float: yes
        number_sections: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      eval = FALSE,
                      warning = F,
                      error = F,
                      message = F)
```


Ce document vise à rassembler les commandes utiles pour programmer en R.

---

# Départ d'analyse


## Import données


+ **JSON**

```{r}
decp_Lambersart <- fromJSON(txt = "../data/decp/decp_Lambersart.json", flatten = T)
decp_Lambersart <- as.data.frame(decp_Lambersart$marches) |> 
  mutate(titulaires = map(titulaires, ~ mutate(.x, id = as.character(id)))) |> 
  unnest(cols = c(titulaires))
```

+ **XML**

```{r}
data_19 <- xmlParse(content(GET("https://marchespublics596280.fr/app.php/api/v1/donnees-essentielles/contrat/xml-extraire-criteres/50286/a:1:%7Bi:0;i:0;%7D/1/2019/false/false/false/false/false/false/false/false/false", user_agent("Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36")), "text"), 
                      encoding = "UTF-8")
xml_df_19 <- xmlToDataFrame(nodes = getNodeSet(data_19, "//marche")) |> mutate(Year = 2019)
```

+ **bibTex**

```{r}
hal1 <- read_bibtex("https://api.archives-ouvertes.fr/search/?q=+publicationDateY_i%3A[2018+TO+2020]+AND++(docType_s%3ACOMM)&fq=collCode_s%3AINRIA2&rows=100000&wt=bibtex")
```

+ **Multiple CSV into folder**

```{r}
rbindlist_fread <- function(path, pattern = "*.csv") {
    files = list.files(path, pattern, full.names = TRUE)
    data.table::rbindlist(lapply(files, function(x) fread(x)))
}
data <- rbindlist_fread("mon/super/path")
```

+ **ZIP**

```{r}
download.file("https://www.insee.fr/fr/statistiques/fichier/5359146/dossier_complet.zip", "dossier_complet.zip")
unzip("dossier_complet.zip")
data <- read_delim("dossier_complet.csv", ";", trim_ws = TRUE)
```



### API

+ **Open Alex**

```{r}
parse_api_open_alex <- function(start, end){
    
    # Import des données : Works dataset, appels de l'API
    works_data <- purrr::map(
        .x = dois_bso[start:end,]$doi,
        .y = data.frame(matrix(ncol = 1, nrow = 1)),
        possibly(.f = ~fromJSON(txt = paste("https://api.openalex.org/works/mailto:diane@datactivist.coop/doi:", .x, sep = ""), flatten = T), otherwise = NA_character_),
        .default = NA)
    
    # Aplatissement
        # sélection des 2 variables qui nous intéressent
    works_df <- purrr::map(
        .x = works_data,
        .y = data.frame(matrix(ncol = 1, nrow = 1)),
        possibly(.f = ~unnest(data.frame(    # on récupère chaque élément/variable qui nous intéresse, on les met dans un df
                       doi = .x$doi, 
                       .x$authorships),
                   cols = "institutions", names_repair = "universal") |> select(doi, country_code), otherwise = NA_character_), 
        .default = NA)
        # suppression des NA et mise au format tabulaire
    works_df <- works_df[works_df !=  "NA"] # replace NA (DOIs non matchés avec OpenAlex) by NULL
    works_df <- rrapply(works_df, condition = Negate(is.null), how = "prune") #remove NULL
    works_df <- works_df |> bind_rows()
    
    # Export du df
    rio::export(works_df, glue("data/3.external/OpenAlex/french_CA/API_{start}_{end}.csv"))

}


### On applique la fonction par 50.000 DOIs (~1h15 pour 10.000 appels)
parse_api_open_alex(1,50000)
```


### Web scraping

+ **Easy scraping (data into table in 1 page)**

```{r}
library(rvest)
content <- read_html("https://www.saint-marcellin.fr/services/vie-commerciale/commerces")
body_table <- content |> html_nodes('body')  |>
                    html_nodes('table') |>
                    html_table(dec = ",") 
data <- body_table[[1]]
```

+ **Middle scraping (data into table in multiple pages)**

```{r}
library(rvest)
data <- purrr::map(
        .x = (as.data.frame(rep(1:5, each = 1)) |> rename(page = `rep(1:5, each = 1)`))$page,
        .y = data.frame(matrix(ncol = 1, nrow = 1)),
        .f = ~read_html(paste0("http://portal.core.edu.au/conf-ranks/?search=&by=all&source=all&sort=atitle&page=", .x)) |> html_nodes('body')  |> html_nodes('table') |> html_table(dec = ","), 
        .default = NA)
data <- bind_rows(data)
```


+ **Difficult scraping (data in the body text in multiple pages)**

```{r}
library(htm2txt)
core_millesime <- purrr::map(
        .x = (as.data.frame(rep(1:10, each = 1)) |> rename(page = `rep(1:10, each = 1)`))$page,
        .y = data.frame(matrix(ncol = 1, nrow = 1)),
        possibly(.f = ~ as.data.frame(gettxt(paste0('http://portal.core.edu.au/conf-ranks/', .x))) |> #import page par page
    rename(text = 1) |> 
    mutate(text = strsplit(as.character(text), "\n")) |> unnest(text) |> #split les éléments séparés par des "\n"
    filter(row_number() ==  10 | #nom de conférence
               grepl("Acronym:", text) ==  TRUE | 
               grepl("Source:", text) ==  TRUE | 
               grepl("Rank:", text) ==  TRUE, #champs que l'on garde
           grepl("DBLP", text) ==  FALSE) |> #retrait de la ligne contenant ce string
    mutate(text = case_when(row_number() ==  1 ~ paste("Title:", text), TRUE ~ text), #ajout du préfixe "titre:"
           champ = str_extract(text, "^[a-zA-Z0-9_]*"), #dans une nouvelle colonne ce qui est avant ":"
           value = str_extract(text, "(?< = : )[^\n]*")) |> #dans une nouvelle colonne ce qui est après ": "
    select(-text) |> t() |> row_to_names(row_number = 1) |> data.frame() |> #transpose puis 1ère ligne en nom de colonnes
    pivot_longer(cols = -c(Title, Acronym), names_to = "number", values_to = "value", names_prefix = "Source|Rank") |> # format long pour rank et source quand multiples
    mutate(col = case_when(row_number() %% 2 ==  0 ~ "rank",
                           row_number() %% 2 ==  1 ~ "source")) |> #
    pivot_wider(names_from = col, values_from = value) |> select(-number) |> mutate(core_id = .x), otherwise = NA_character_),
        .default = NA)

# Gestion des Na et mise au format tabulaire
core_histo <- core_millesime[core_millesime !=  "NA"] # replace NA by NULL
core_histo <- rrapply::rrapply(core_histo, condition = Negate(is.null), how = "prune") #remove NULL
core_histo <- core_histo |> bind_rows()
```


## Librairies, noms

+ **Multiple libraries**

```{r}
packages = c("tidyverse", "jsonlite", "glue", "parallel", "doParallel", "foreach")
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)
```

+ **Clean column names**

```{r}
data <- data |> 
  janitor::clean_names()
```

+ **Rename all columns with suffix except one**

```{r}
rename_at(vars(-Name, -State), ~ paste0(., '_2017'))
```




# Manipulations de variables 

## Modification de variables

### Dates

+ **Change date format**

```{r}
data$Date <- format(as.Date(data$Date, format = "%Y-%m-%d %H:%M:%S"),"%d %B %Y") #30 mai 2023
# autres formats : https://www.r-bloggers.com/2013/08/date-formats-in-r/
```

+ **Dates subtraction**

```{r}
data <- data |> mutate(age = round(as.numeric(difftime(Sys.Date(), dateOfBirth, units = "weeks")) / 52.1429, 0), #année
                       nb_weeks = round(as.numeric(difftime(fin, Sys.Date(), units = "weeks")), 0), #semaine
                       nb_month = round(as.numeric(difftime(fin, Sys.Date(), units = "weeks") /4.34524), 0)) #mois
```

+ **Dates sum**

```{r}
library(mondate)
data <- data |> mutate(date_fin = as.mondate(date_debut) + duree) #duree en mois
```

+ **Round multiple columns**

```{r}
data <- data |> mutate_at(vars(var_3:var_17), ~round(.,0))
```


### Valeurs manquantes, NAs

+ **Fill NAs with previous values by group**

```{r}
data <- data |> 
    group_by(`Référence commande`) |> 
    fill(everything(), .direction = "downup") |> 
    ungroup()
```



### Remplacement de valeurs

+ **Replace string**

```{r}
# Valeurs d'une colonne
data$column <- str_replace_all(data$column, c("pattern1 | pattern2" = "replacement"))

# Valeurs du df entier
data <- data |> mutate_all(function(x) gsub("pattern1 | pattern2", "replacement", x))
```


+ **Remove all special characters**

```{r}
# Supprimer les caractères spéciaux ex : ? ' !
data <- data |> mutate(col = str_replace_all(col, "[^[:alnum:]]", " "))
```


+ **Replace NA**

```{r}
# NAs d'une colonne par 0
data <- data |> mutate(col = replace_na(col, 0))

# NAs du df entier par 0
data <- data |> mutate_all(replace_na, replace = 0)

# NAs par string
data <- data |> replace(is.na(.), "unknown_by_WOS")

# NAs par valeurs autre colonne
data <- data |> mutate(col_NA = coalesce(col_NA, col_replace))
```


+ **Replace by NA**

```{r}
# Cellules vides par NAs
data <- data |> mutate_all(na_if, "")

# NULL par NAs
data <- data |> replace(. == "NULL", NA) 
data[data ==  "null"] <- NA

# Chiffres négatifs par NAs
data <- data |> mutate(col = replace(col, which(col<0), NA))

# Valeur par NAs sur certaines colonnes
data <- data |> mutate(across(starts_with("Choix_"), ~ na_if(.x, "Pas de préférence")))
```

+ **Shaping numeric variables**

```{r}
# Nombres arrondis au million
format(round(100000000 / 1e6, 1), trim = TRUE)

# Centaines et milliers séparés des virgules
format(as.integer(1000000, 0), nsmall = 1, big.mark = ".")
```


### Aplatissement de listes

```{r}
data <- data |>
    pull(column) |> pluck() |> bind_rows() |> 
    group_by(author_id) |> mutate(n = n()) |> select(author_id, n) |> distinct()
```


### Format de variables

+ **Pivot longer**

```{r}
m3 <- Eau_groupe5 |> select(c(BATIMENTS:TYPE_DE_BATIMENTS, starts_with("m3"))) |> 
    mutate_all(as.character) |> 
    pivot_longer(cols = -c(BATIMENTS:TYPE_DE_BATIMENTS), names_to = "Annee", values_to = "m3", names_prefix = "m3_")
montant <- Eau_groupe5 |> select(c(BATIMENTS:TYPE_DE_BATIMENTS, starts_with("montant"))) |> 
    mutate_all(as.character) |> 
    pivot_longer(cols = -c(BATIMENTS:TYPE_DE_BATIMENTS), names_to = "Annee", values_to = "montant", names_prefix = "montant_")
final <- cbind(m3, montant |> select(montant))
```

+ **Pivot wider**

```{r}
data <- data |> 
    pivot_wider(names_from = choix, values_from = nb_interesses, names_prefix = "choix_")
```

+ **Split comma separated values**

```{r}
# Split 
unnested_bso <- unnested_bso |> mutate(journal_issns = strsplit(as.character(journal_issns), ",")) |> unnest(journal_issns)
# Unsplit
unnested_bso <- unnested_bso |> mutate(journal_issns = paste0(unique(na.omit(journal_issns)), collapse = ","))
```




## Création de variables

+ **Merge 2 columns into 1**

```{r}
data <- data |> mutate(new_col = coalesce(col1,col2,col3))
```

+ **Calculate sum accross mutliple columns df**

```{r}
data |> rowwise() |> mutate(sum_multiple = sum(c_across(var_3:var_17)))
```

### Valeurs aléatoires, indices, `rep()`, `seq()`

+ **Index rep**

```{r}
c(rep(1:5570, each = 50), rep(5571, each = 7))
```

+ **Between groups index (not within)**

```{r}
data <- data |> 
    group_by(defi_profil) |> 
    mutate(groupNbr = cur_group_id())
```

+ **Intervals on numeric variable**

```{r}
data <- data |> mutate(tranche_age = cut(age, c(18,20, seq(30, 90, 5), 98)))
```

+ **Random values**

```{r}
random <- c("groupe 1", "groupe 2", "groupe 3")
sample(random, size = nrow(data), replace = TRUE, prob = c(9/10,0.06,0.04))
```



## Chaînes de caractères

+ **Upper string and remove special characters**

```{r}
data <- data |> mutate(col = stringi::stri_trans_general(str = gsub("-", " ", toupper(string)), id = "Latin-ASCII"))
```

+ **Upper first letter of both words**

```{r}
library(tools)
toTitleCase(tolower("MY STRING"))
toTitleCase("my other string")
```

+ **Remove specific words/characters**

```{r}
data <- data |> mutate(col = removeWords(string, c("IEEE ", "ACM ", "SIAM ")))
```

+ **Remove duplicated words**

```{r}
rem_dup_word <- function(x){
  #x <- tolower(x)
  paste(unique(trimws(unlist(strsplit(x, split = " ", fixed = F, perl = T)))), collapse = " ")
}
rem_dup_word(x)
```

+ **Remove isolated letters/characters**

```{r}
data <- data |> mutate(col = gsub("\\W*\\b\\w\\b\\W*", " ", string))
```

+ **Remove blank spaces at the begining (or the end)**

```{r}
data <- data |> mutate(col = trimws(string, which = "left"))
```

+ **Keep first word**

```{r}
data <- data |> mutate(first_word = word(string, 1))
```

+ **Extract digits**

```{r}
library(strex)
data <- data |> mutate(min = str_nth_number(string, n = 1)) # extrait le 1er chiffre du string
```

+ **Extract year**

```{r}
data <- data |> mutate(annee = str_extract(`En quelle année ?`, "(1|2)\\d{3}")) #"\\d{5}" pour zipCode
```

+ **Extract n first characters**

```{r}
data <- data |> mutate(sub_string = substr(data$string, 1, n))
```

+ **Extract n last characters**

```{r}
data <- data |> mutate(sub_string = substr(data$string, nchar(data$string)-n+1, nchar(data$string)))
```

+ **Add digit identifiant**

```{r}
data <- data |> mutate(num = sprintf("%02d", num)) #passer de 1 à 2 digits
data <- data |> mutate(num = str_pad(num, 14, pad = "0")) #obliger à avoir 14 caractères (donc ajoute 0 en début si besoin)
```

+ **Remove first digit if 0**

```{r}
data <- data |> mutate(num = gsub("^0", "", num))
```

+ **Only 1 character in a string**

```{r}
nchar(string) ==  1
```





### Regular expressions (regex)

+ **Detect digits**

```{r}
str_detect(string, "[0-9]") ==  TRUE
grep("\\d+", string, value = TRUE) 
```

+ **Detect special characters (i.e. no letter nor digit)**

```{r}
grepl('[^[:alnum:]]', string)
```

+ **Detect dates with format "%Y-%m-%d %H:%M:%S"**

```{r}
grepl("\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}", string)
```

+ **Extract characters before first digit**

```{r}
str_extract(string, "^\\D+")
```

+ **Extract characters before ":"**

```{r}
str_extract(string, "^[a-zA-Z0-9_]*")
```

+ **Extract characters after ": "**

```{r}
str_extract(string, "(?<=: )[^\n]*")
```

+ **Extract characters after "["**

```{r}
str_extract(string, "(?<=\\[).*")
```

+ **Extract characters before "["**

```{r}
str_extract("string bla [da]", "^.*\\[") #crochet inclu dans l'extraction
```

+ **Extract characters before "("**

```{r}
str_extract(string, "^[^(]+")
```

+ **Extract characters between parenthesis**

```{r}
str_extract(string, "\\(.*?\\)")
```



## Filtres

+ **Remove values containing string**

```{r}
data <- data |> filter(!grepl(',', column)) #containing comma
```

+ **Keep values containing string**

```{r}
data <- data |> filter(grepl("mot particulier", column) ==  TRUE)
data <- data |> filter_all(all_vars(grepl("mot", .)))
```

+ **Even and odd lines**

```{r}
data |> filter(row_number() %% 2 ==  0) # pair
data |> filter(row_number() %% 2 ==  1) # impair
```

+ **All columns equal a value**

```{r}
data |> group_by(cat) |> filter(across(where(is.character), ~. != "N/A"))
```

## Fonctions


+ **Export object created within function**

```{r}
assign(glue("n_{year}"), n, envir = .GlobalEnv)
```

+ **Detach created object from environment**

```{r}
rm(ls = inter_bv, ratio, area_commune, area_2017)
```

+ **Possibly function treatment**

```{r}
tryCatch(heures_prevues(salarie), error = function(e) NULL)
```

+ **Use function saved in other directory**

```{r}
source(here("functions", "match_commune.R"))
object <- memoise::memoise(match_commune, cache = memoise::cache_filesystem(here("cache")))
```

+ **Call variable within created function**

```{r}
fonction <- function(data, variable){
    data |> filter({{variable}} == 2)
}
```

+ **Rename column wihtin created function**

```{r}
fonction <- function(new_cols, cols){
    data |> rename({{ new_cols }} := {{ cols }}) 
}
```

+ **Huge utilisation created function**

```{r}
library(purrr)
purrr::map(.x = c(13:16, 18, 26:38, 40:44, 46, 49, 55, 66:68, 70, 84:90, 93:96, 99:108, 111:113, 115, 139, 162:178, 180, 181, 188:197),
          .f = ~table_recap_simple(.x))
table_recap_stat <- rbind(lapply(ls(pattern="^all_stat_"), function(x) get(x))) |> 
    bind_rows()
```



## Autre

+ **Redundancy test**

```{r}
identical(data$doi, data$id)
```

+ **Increase total system memory R session**

```{r}
library(unix) #pour linux
rlimit_as(1e20)  #increases to ~12GB
```

# Manipulations de dataframes

+ **Fuzzy join**

```{r}
library(fuzzyjoin)
data <- stringdist_left_join(data, data2, by = "col_name", max_dist = 5, distance_col = "distance") |> 
  group_by(nom) |> slice_min(distance)
```

+ **Merge 2 dataframes ~`rbind()`**

```{r}
data_merged <- merge(df_1, df_2, all = TRUE) 
```

+ **Alternative `rbind()` when different number of columns**

```{r}
data <- list(cat1, cat2) |>  bind_rows(.id = 'origine_df')
```

+ **Differences 2 dataframes**

```{r}
anti_join(df1, df2)
```

+ **Similarities 2 dataframes**

```{r}
semi_join(df1, df2)
```

---

# Analyse

## Statistiques

+ **NAs per column of a dataframe**

```{r}
# Une colonne
data |> count(is.na(col_name))

# Toute les colonnes
nb_NA <- as.data.frame(apply(is.na(bso_data), 2, sum)) |> 
                       rename(`nombre de NA` = `apply(is.na(bso_data), 2, sum)`) |>
                       mutate(pourcentage = `nombre de NA`/nrow(bso_data)*100) |> 
                       mutate(pourcentage = round(pourcentage, 2)) |> 
                       arrange(desc(pourcentage))
```

+ **Non NAs per group**

```{r}
table <- data |> 
    group_by(group) |> 
    summarise_all(list(~sum(!is.na(.))))
```

+ **Values frequency**

```{r}
data <- as.data.frame(table(data$column))  #R base
data <- data |> group_by(group) |> count(column)   #dplyr
data <- data |> group_by(group, column) |> summarise(n = n()) #dplyr
```

+ **Sum in pipe for specific rows**

```{r}
data |> mutate(new_cat = sum(n[Catégorie2 == "Total"]))
```


## Visualisations

+ **Reorder values before plotting**

```{r}
# geom_bar ordre alphabetic, après arrange()
mutate(colonne = factor(colonne, levels = rev(unique(colonne)))) 
# geom_bar décroissant selon n
mutate(colonne = fct_reorder(colonne, n))
```

+ **Arrange multiple plots**

```{r}
# Afficher plusieurs ggplots
library(gridExtra)
grid.arrange(g1,g2,g3, ncol = 3, nrow = 1, 
             top = grid::textGrob("Titre", gp = grid::gpar(fontsize = 15, font = 2)))
# Aligner les boxes
library(cowplot)
plot_grid(p3.1, p3.2, p3.3, p3.4, p3.5, align = 'vh')
# Afficher plusieurs ggplotlys
library(plotly)
subplot(plotly_positif, plotly_negatif, nrows = 1)

# Pas de message grid.arrange() dans rmd
graph <- grid.arrange(g1,g2)
grid::grid.draw(graph)
```

+ **Interactive graph**

```{r}
# Passer en plotly
ggplotly(graph, tooltip = c("text")) |> 
    layout(xaxis = list(autorange = TRUE), yaxis = list(autorange = TRUE)) #auto adjust scale when click on element

# Passer en giraph : mettre les geométries en interactif !! ex: geom_segment_interactive()
girafe(print(graph), width_svg = 15, height_svg = 12)
```

+ **Custom theme() BBC**

```{r}
font <- "Helvetica"
custom_theme <- function (){
    font <- "Helvetica"
    ggplot2::theme(plot.title = ggplot2::element_text(family = font,size = 21, face = "bold", color = "#222222"), 
        plot.subtitle = ggplot2::element_text(family = font,size = 18, face = "italic", margin = ggplot2::margin(0, 0, 9, 0)), 
        plot.caption = ggplot2::element_text(family = font,size = 18, margin = ggplot2::margin(9, 0, 9, 0)), 
        legend.title = ggplot2::element_text(family = font, size = 18, color = "#222222"), 
        legend.position = "top", 
        legend.text.align = 0, 
        legend.background = ggplot2::element_blank(),
        legend.key = ggplot2::element_blank(),
        legend.text = ggplot2::element_text(family = font, size = 18,color = "#222222"), 
        axis.text = ggplot2::element_text(family = font, size = 15,color = "#222222"), 
        axis.text.x = ggplot2::element_text(margin = ggplot2::margin(5,b = 10)), 
        axis.title = ggplot2::element_text(family = font, size = 18,color = "#222222"),
        axis.ticks = ggplot2::element_blank(),
        axis.line = ggplot2::element_blank(), 
        panel.grid.minor = ggplot2::element_blank(),
        panel.grid.major.y = ggplot2::element_line(color = "#cbcbcb"),
        panel.grid.major.x = ggplot2::element_blank(), 
        panel.background = ggplot2::element_blank(),
        strip.background = ggplot2::element_rect(fill = "white"),
        strip.text = ggplot2::element_text(size = 22, hjust = 0, face = "bold"))
}
custom_theme_largeG <- function (){
    font <- "Helvetica"
    ggplot2::theme(plot.title = ggplot2::element_text(family = font,size = 25, face = "bold", color = "#222222"), 
        plot.subtitle = ggplot2::element_text(family = font,size = 18, face = "italic", margin = ggplot2::margin(0, 0, 9, 0)), 
        plot.caption = ggplot2::element_text(family = font,size = 18, margin = ggplot2::margin(9, 0, 9, 0)), 
        legend.title = ggplot2::element_text(family = font, size = 18, color = "#222222"), 
        legend.position = "top", 
        legend.text.align = 0, 
        legend.background = ggplot2::element_blank(),
        legend.key = ggplot2::element_blank(),
        legend.text = ggplot2::element_text(family = font, size = 18,color = "#222222"), 
        axis.text = ggplot2::element_text(family = font, size = 24,color = "#222222"), 
        axis.text.x = ggplot2::element_text(margin = ggplot2::margin(5,b = 10)), 
        axis.title = ggplot2::element_text(family = font, size = 27,color = "#222222"),
        axis.ticks = ggplot2::element_blank(),
        axis.line = ggplot2::element_blank(), 
        panel.grid.minor = ggplot2::element_blank(),
        panel.grid.major.y = ggplot2::element_line(color = "#cbcbcb"),
        panel.grid.major.x = ggplot2::element_blank(), 
        panel.background = ggplot2::element_blank(),
        strip.background = ggplot2::element_rect(fill = "white"),
        strip.text = ggplot2::element_text(size = 22, hjust = 0, face = "bold"))
}

# change grid when coord_flip()
theme(panel.grid.major.x = ggplot2::element_line(color = "#cbcbcb"),
      panel.grid.major.y = ggplot2::element_blank())
```

### Par élément

+ **Geometry**

```{r}
# Geométrie initiale
  geom_line(size = 1.7, alpha = 0.9, linetype = 1, color = "#0066CC") +
  geom_point(colour = "#0066CC", fill = "#0066CC", size = 2, pch = 21, stroke = 1.5) +
  geom_bar(stat = "identity", position = "dodge", width = .6, col = "white", size = 2, fill = "#21468d") +
  geom_bar(aes(x = forcats::fct_infreq(adequation))) + #fct_infreq pour ordonner selon count
  geom_col(position = "stack", width = 0.7, color = "white") +  coord_flip() + #cas particulier de geom_bar où on prend n comme Y et non count
  geom_text_wordcloud(family = "Montserrat") +
# Géométrie additionnelle
  geom_text(aes(y = 1, label = title_projet, hjust = "bottom"), #aligner geom_text à gauche avec coord_flip
            fontface = "italic", size = 5) +
  geom_label(aes(y = 1, label = title_projet, hjust = "bottom"), fontface = "italic", size = 2.6,
             fill = "white", label.size = NA) + #white background and remove black borders
  stat_count(geom = "text", colour = "white", size = 4,
             aes(label = ..count.., y = ..count..+.7), #y pour positionnement juste au dessus des barres
             position = position_stack(vjust = 0.5)) + #geom_text des geom_bar sans y
  geom_vline(xintercept = -.5, linetype = 2) +
```

+ **Scales**

```{r}
  xlim(1, 100) +
  scale_y_continuous(labels = scales::comma) + #grands chiffres lisibles
  scale_y_continuous(breaks = scales::pretty_breaks()) + #breaks réguliers, plus lisible (pas d'axe)
  scale_y_continuous(labels = scales::percent, limits = c(0,1)) + # pourcentages
  scale_y_discrete(limits = 1:12) + #valeurs discrètes
  scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 50)) + #axis-text trop longs sur plusieurs lignes
  scale_color_continuous(high = "#132B43", low = "#56B1F7") #reverse color
  scale_y_continuous(breaks = c(0, 2, 4, 6, 8, 10), limits = c(-.2, 10)) # de 0 à 10 avec les breaks spécifiés
```

+ **Labs**

```{r}
# titres trop longs, automatiquement coupés
title = stringr::str_wrap("Commençons par la protection de la vie privée. Considérez-vous que votre structure est en conformité avec le RGPD ?", width = 45)
```

+ **Theme**

```{r}
  theme_classic() +
  theme(legend.position = "bottom",
        panel.grid.major.y = ggplot2::element_line(color = "#cbcbcb"), #lignes horizontales fond graphique en gris (BBC thème)
        strip.text.x = element_text(face = "bold"), #label des facettes
        axis.title.x = element_text(margin = margin(t = 5, r = 0, b = 5, l = 0)), #augmenter marges entre texte et labels des axes
        plot.title = element_textbox_simple(hjust = 1), #hujst: titre aligné à droite, element_textbox_simple line break auto titre
        plot.background = element_rect(fill = "#FAF3EE", colour = "#FAF3EE"), #background couleur Datactivist
        panel.background = element_rect(fill = "#FAF3EE", colour = "#FAF3EE"),
        legend.background = element_rect(fill = "#FAF3EE", colour = "#FAF3EE")) +
```

+ **Facet**

```{r}
  facet_grid(Projet ~ ., 
             scales = "free", #scales = "free" pour label différents d'une facette à une autre
             space = "free") + #space = "free" pour hauteur différentes selon le nombre d'éléments par facette
  facet_zoom(x = annee > 2014, split = TRUE) +
  ggforce::facet_col(facets = vars(Projet), 
                     scales = "free_y", 
                     space = "free") # pour avoir scales et face de facet_grid avec labels to the top de facet_wrap
  facet_wrap(~vote, scales='free_x') + scale_y_continuous(limits=c(0 ,50)) # pour avoir les ticks sur chaque facettes et pas juste celles du bas
```

+ **Legend**

```{r}
  guides(fill = guide_legend(nrow = 6, byrow = TRUE,  # nombre d'éléments par ligne
                             title = "titre légende"), # titre légende
        lwd = "none",  #ne pas afficher une légende en particulier
        col = guide_legend(title = "", reverse = TRUE, override.aes = list(lwd = 2))) + #lwd = 2 pour ligne plus épaisse et plus visible dans la légende
```

+ **Colors**

```{r}
scale_fill_manual(values = c("#c898ae", "#da4729", "#f38337", "#74a466", "#fecf5d", "#5E79AC")) #couleurs Bauhaus
```





### Graphiques

```{r eval = T, echo = F}
data(iris)
iris <- janitor::clean_names(iris)
library(tidyverse)
```

+ **Donut**

```{r eval = T, out.width = '60%', fig.align = 'center'}
iris |> 
    group_by(species) |> summarise(Freq = n()) |> 
    mutate(fraction = Freq / sum(Freq),
           proportion = round((Freq / sum(Freq))*100),
           ymax = cumsum(fraction),
           ymin = c(0, head(ymax, n = -1)), 
           labelPosition = (ymax + ymin) / 2) |> 
    ggplot(aes(ymax = ymax, ymin = ymin, xmax = 3.3, xmin = 2, fill = species)) +
      geom_rect(col = "white", linewidth = 2) +
      geom_text(x = 4, aes(y = labelPosition, label = paste(proportion,"%",sep = "")), color = "#333333", size = 7) +
      geom_text(aes(x = 0, y = 0, label = sum(Freq)), col = "#333333", alpha = 0.8, size = 14, fontface = "bold", inherit.aes = FALSE) +
      scale_fill_manual(values = c('#fecf5d', '#21468d','#82888d')) +
      coord_polar(theta = "y") +
      labs(title = "Titre") +
      xlim(c(0, 4)) +   
      theme_void() +
      theme(legend.position = "right",
            plot.title = element_text(face = "bold"))+
      guides(fill = guide_legend(title = ""))
```

+ **Histogram**

```{r eval = T, out.width = '60%', fig.align = 'center'}
iris |> 
    ggplot() +
      aes(x = sepal_length) +
      geom_histogram(bins = 7L, col = "white", fill = "#21468d", width = 5) +
      geom_vline(xintercept = mean(iris$sepal_length, na.rm = TRUE), linetype = 2, col = "red") +
      geom_text(aes(x = mean(sepal_length, na.rm = T), y = 1, label = paste("Moyenne :", round(mean(sepal_length, na.rm = T), 1))), 
                col = "red", fontface = "italic", hjust = 0, size = 5) +
      labs(x = "Valeur",y = "Fréquence", title = "Titre",
           subtitle = paste(iris |> filter(is.na(sepal_length)) |> nrow(), "valeur manquante")) +
      theme_classic() +
      theme(plot.subtitle = element_text(face = "italic"),
            plot.title = element_text(face = "bold")) +
      scale_x_continuous(n.breaks = 10)
```

+ **Histogram on multiple variables**

```{r eval = T, out.width = '60%', fig.align = 'center'}
iris |> 
  #select(1, 37:40) |> 
  reshape2::melt(id.vars = c("species")) |> 
  ggplot(aes(x = value)) +
      geom_histogram(bins = 10L, col = "white", fill = "#21468d", width = 5) +
      labs(x = "Valeur", y = "Fréquence", title = "Titre") +
      theme_classic() +
      theme(plot.title = element_text(face = "bold")) +
      facet_wrap(variable ~ .)
```

+ **Pyramid**

```{r eval = T, out.width = '60%', fig.align = 'center'}
library(lemon)
iris |> 
  filter(species !=  "setosa") |> 
  mutate(tranche_pw = cut(petal_width, c(0.1, 0.5, seq(1, 2.5, .5)))) |> 
  group_by(tranche_pw, species) |> 
  summarise(Freq = n()) |> ungroup() |> group_by(species) |> 
  mutate(percent = Freq / sum(Freq) *100,
         percent = ifelse(percent < 0.5, round(percent, 1), round(percent, 0))) |> 
  na.omit() |> 
  ungroup() |> 
  ggplot(mapping = aes(x = ifelse(species ==  "versicolor", -Freq, Freq), y = tranche_pw, fill = species)) +
      geom_col(col = "white", size = 1.3) + #col = "black"
      geom_text(aes(y = tranche_pw, x = ifelse(species ==  "versicolor", -Freq-1, Freq+1), label = paste(percent,"%",sep = "")), 
                color = "#333333", size = 3, check_overlap = T) +
      scale_x_symmetric(labels = abs) + 
      scale_colour_manual(values = c('#fecf5d', '#21468d'),
                          aesthetics = c("colour", "fill")) +
      labs(x = "Fréquence", y = "", title = "Titre") +
      theme_classic() + 
      theme(legend.position = "right",
            plot.title = element_text(face = "bold"),
            axis.title.y = element_blank(),
            axis.line.y = element_blank(),
            axis.ticks.y = element_blank()) +
      guides(fill = guide_legend(title = ""))
```

+ **Bar**

```{r eval = T, out.width = '60%', fig.align = 'center'}
iris |> 
    group_by(species) |> 
    summarise(n = n()) |> ungroup() |> na.omit() |> 
    mutate(percent = round((n / sum(n))*100, 0)) |> 
    mutate(species = fct_reorder(species, n)) |> 
    ggplot(aes(x = species, y = n))+
        geom_bar(stat = "identity", width = .6, fill = "#21468d") +
        geom_text(aes(y = n+3, x = species, label = paste(percent,"%",sep = "")), 
                color = "#333333", size = 3, check_overlap = T) +
        coord_flip() +
        labs(x = "", y = "Fréquence", title = "Titre") +
        scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 70)) + #axis-text trop longs sur plusieurs lignes
        theme_classic() +
        theme(plot.title = element_text(face = "bold"),
              axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)))
```

+ **Radar**

```{r eval = T, out.width = '60%', fig.align = 'center'}
library(ggradar)
iris |> 
  select(sepal_length, sepal_length:petal_width) |> 
  summarise_all(funs(mean(., na.rm = T))) |> 
  ggradar(values.radar = c("1", "3", "5"),
          grid.min = 1, grid.mid = 3, grid.max = 5,
          # Polygones
          group.line.width = 1, 
          group.point.size = 3,
          group.colours = "#21468d",
          # Arrière-plan et lignes de grille
          background.circle.colour = "white",
          gridline.mid.colour = "grey") +
  xlim(-10,10) + #selon longueur catégories
  labs(title = "Titre") +
  theme(legend.position = "none",
        plot.title = element_text(face = "bold"))
```

+ **Comparison gauge**

```{r eval = T, out.width = '60%', fig.align = 'center'}
comp_data <- data.frame("variable" = c("sepal_length", "sepal_width", "petal_length", "petal_width"),
           "Minimum" = c(min(iris$sepal_length), min(iris$sepal_width), 
                         min(iris$petal_length), min(iris$petal_width)),
           "Maximum" = c(max(iris$sepal_length), max(iris$sepal_width), 
                         max(iris$petal_length), max(iris$petal_width)),
           "Moyenne" = c(mean(iris$sepal_length), mean(iris$sepal_width), 
                         mean(iris$petal_length), mean(iris$petal_width)))
comp_data |> 
  arrange(variable) |> 
  mutate(variable = factor(variable, levels = rev(unique(variable)))) |> 
  ggplot() +
    geom_segment(aes(x = Minimum, xend = Maximum, y = variable, yend = variable, colour = variable), lwd = 10) +
    geom_segment(aes(x = Moyenne, xend = Moyenne+.05, y = variable, yend = variable), 
                 colour = ifelse(comp_data$variable ==  "sepal_length", "white", "black"), lwd = 10) +
    geom_text(aes(x = Moyenne+.2, y = variable, label = paste("Moyenne :", round(Moyenne, 1)), hjust = "bottom"), 
              size = 3, col = ifelse(comp_data$variable ==  "sepal_length", "white", "#333333")) +
    labs(title = "Titre", x = "Score", y = "") +
    scale_y_discrete(labels = function(x) stringr::str_wrap(x, width = 50)) +
    scale_color_manual(values = c("petal_length" = "#21468d", 
                                  "sepal_width" = "#fecf5d", 
                                  "sepal_length" = "#d55152", 
                                  "petal_width" = "#ddd6ad")) +
    theme_bw() +
    theme(legend.position = "none", 
          plot.title = element_text(face = "bold"))
```

+ **Infographie simple**

```{r}
library(icons)
library(tidyverse)
# Table
df <- data.frame(
    x = c(2, 8.5, 15, 21.5),
    y = rep(6.5, 4),
    h = rep(4.25, 4),
    w = rep(6.25, 4),
    value = c(5, 7, 17, 5),
    info = c("Communes",
             "Participants",
             "Jeux de données \nouverts",
             "Réutilisations"),
    color = factor(1:4)
)

# Graphique
ggplot(df, aes(x, y, height = h, width = w, label = info)) +
    ## Create the tiles using the `color` column
    geom_tile(aes(fill = color)) +
    ## Add the numeric values as text in `value` column
    geom_text(color = "white", fontface = "bold", size = 16,
              aes(label = ifelse(value > 999, format(as.integer(value, 0), nsmall = 1, big.mark = "."), value), 
                  x = x, y = y + 0.7), 
              hjust = 0.5) +
    ## Add the labels for each box stored in the `info` column
    geom_text(color = "white", fontface = "bold", size = 10,
              aes(label = info, x = x - 2.9, y = y - 1), hjust = 0) +
    coord_fixed() +
    #scale_fill_manual(type = "qual", palette = "Dark2") +
    scale_fill_manual(values = c("#9bcea4", "#ef7875", "#ffcc00", "#23ae84", "#fecf5d", "#21468d")) +
    ## Use `geom_text()` to add the icons by specifying the unicode symbol.
    theme_void() +
    guides(fill = FALSE)
```

## Tables

+ `gttable()`

```{r}

```

+ `DT::datatable()`

```{r}


```



---

# Fin d'analyse

+ **Export CSV**

```{r}
rio::export(data, "~/Downloads/tableau.csv")
write.csv(data, "~/Downloads/tableau.csv", row.names = FALSE, fileEncoding = "UTF-8")
```

+ **Export plots**

```{r}
saving_plot <- function(graph, name, width, height) {
  ggsave(file = glue("~/Downloads/SVG/{name}.svg"), plot = graph, width = width, height = height)
  ggsave(file = glue("~/Downloads/PNG/{name}.png"), plot = graph, width = width, height = height)
}
saving_plot(graph, "histogram", 9, 5)
```

+ **Export leaflet map**

```{r}
library(htmlwidgets)
saveWidget(map, file = "ma_carte.html")
```



----

# R Markdown


+ **Footer, css, header files in other folder**

```{r}
includes:
    in_header: !expr here::here("inst/rmarkdown/resources/header.html")
```

+ **Output file into 'reports' folder**

```{r}
knit: (
  function(inputFile, encoding) { 
    rmarkdown::render(inputFile, params = "ask",  
      encoding    = encoding,
      output_dir = "../reports", 
      output_file = paste0(tools::file_path_sans_ext(inputFile), ".html")) })
```

+ **Justify text**

```{r}
<style>
body {
text-align: justify
}
</style> 
```

+ **Custom dfsummary**

```{r}
print(dfSummary(data_summary, style = "grid", graph.magnif = 1, 
                valid.col = FALSE, varnumbers = FALSE, tmp.img.dir = "/tmp", 
                max.distinct.values = 5, headings = FALSE, method = "render", 
                col.widths  = c(300, 200, 100, 50, 20)),
      max.tbl.height = 600,
      method = "render")
```

+ **Use installed font family**

```{r}
library(showtext)
font_add("Nexa", regular = "Nexa Bold.otf")
font_add("Trade Gothic", regular = "Trade Gothic.otf")
showtext_auto()
# then specify on the CSS the name of the font
```

+ **Python on Rmd**

```{r}
# En début de Rmd
library(reticulate)
py_install("pandas")

# Pour utiliser un environnement virtuel
Sys.setenv(RETICULATE_PYTHON = "path/to/python.exe") 
virtualenv_create("test_proj")
py_install("pandas", envname = "test_proj", method = "auto")
use_virtualenv("test_proj")
```

```{python}
#```{python}
import pandas
import plotly.express as px
matrice = [[43, 57], [12, 88]]
fig = px.imshow(matrice)
fig.show()
```

+ **Remove blank space end RMD file**

```{r}
<div class = "tocify-extend-page" data-unique = "tocify-extend-page" style = "height: 0;"></div>
```

+ **RMD collaboratif**

```{r}
# Déposer Rmd sur GDrive pour travailler en collaboration   
    # LE METTRE DANS UN DOSSIER TRACKDOWN ET LE NOM EN LIGNE DOIT GARDER L'EXTENSION .RMD
trackdown::upload_file(file = "scripts/Rapport_final.Rmd", gfile = "Rapport_final.Rmd")
trackdown::download_file(file = "scripts/Rapport_final.Rmd", gfile = "Rapport_final.Rmd")
```


---

# Autre

+ **Bash commands in R**

```{r}
system(glue("cat {in_dir}/study-apc_{year}.jsonl | jq -c '{{doi, year, bso_classification, hal_id}}' | jq --slurp > {out_dir}/unnested_bso_{year}.json"))
```

+ **Parallel execution command**

```{r}
library(parallel)
library(doParallel)
library(foreach)
years <- 2013:2020

numCores <- 2
registerDoParallel(numCores)

foreach (year = years) %dopar% {
  subjson_bso(year)
}

stopImplicitCluster()
```

+ **Icons**

[https://fontawesome.com/v5.15/icons?d = gallery&p = 2]()

[https://ionic.io/ionicons]()

[https://jpswalsh.github.io/academicons/]()


<div class = "tocify-extend-page" data-unique = "tocify-extend-page" style = "height: 0;"></div>
